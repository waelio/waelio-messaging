<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Messaging Hub UI</title>
    <!-- Favicons & PWA icons -->
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <link rel="icon" href="/favicon.ico" />
    <link
      href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900|Material+Icons"
      rel="stylesheet"
      type="text/css"
    />
    <link
      href="https://cdn.jsdelivr.net/npm/quasar@2.18.5/dist/quasar.prod.css"
      rel="stylesheet"
      type="text/css"
    />
    <style>
      html,
      body,
      #q-app {
        height: 100%;
      }
      body {
        margin: 0;
      }
      .message-item.me {
        align-self: flex-end;
      }
      .message-item.other {
        align-self: flex-start;
      }
      .message-item.broadcast {
        align-self: center;
      }
    </style>
  </head>
  <body>
    <div id="q-app"></div>
    <script src="https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/quasar@2.18.5/dist/quasar.umd.prod.js"></script>
    <script type="module">
      import { uStore } from "https://esm.sh/@waelio/ustore@1.0.8";
      window.uStore = uStore;
    </script>
    <script>
      const { ref, computed, onMounted, watch } = Vue;
      const WS_URL =
        (location.protocol === "https:" ? "wss://" : "ws://") + location.host;
      const app = Vue.createApp({
        setup() {
          const connected = ref(false);
          const socket = ref(null);
          const clientId = ref("");
          const users = ref([]);
          const messages = ref([]);
          const input = ref("");
          const typingUsers = ref(new Set());
          // Deterministic per-user color palette (avoid reserved UI semantic colors except primary for self & accent for broadcast)
          const userPalette = [
            "indigo",
            "teal",
            "deep-orange",
            "amber",
            "lime",
            "purple",
            "cyan",
            "pink",
            "green",
            "blue-grey",
            "brown",
          ];
          function colorFor(id) {
            if (!id) return "grey";
            let hash = 0;
            for (let i = 0; i < id.length; i++) {
              hash = (hash * 31 + id.charCodeAt(i)) >>> 0;
            }
            const base = userPalette[hash % userPalette.length];
            const shade = 7; // mid shade for readability
            return `${base}-${shade}`;
          }
          const roomId = ref(null);
          const roomPartner = ref(null);
          const selectedUser = ref(null);
          const notifyEnabled = ref(true);
          const isDark = ref(Quasar.Dark.isActive);
          const themeAuto = ref(false);
          const themeButtonLabel = computed(() =>
            themeAuto.value ? "System" : isDark.value ? "Light" : "Dark"
          );
          const themeButtonIcon = computed(() =>
            isDark.value ? "light_mode" : "dark_mode"
          );
          // Restore persisted state (best-effort)
          try {
            const savedNotify = window.uStore?.local.get("notifyEnabled");
            if (typeof savedNotify === "boolean")
              notifyEnabled.value = savedNotify;
            const savedSelected = window.uStore?.local.get("selectedUser");
            if (savedSelected) selectedUser.value = savedSelected;
            const savedDraft = window.uStore?.local.get("inputDraft");
            if (typeof savedDraft === "string") input.value = savedDraft;
            const savedDark = window.uStore?.local.get("themeDark");
            const savedAuto = window.uStore?.local.get("themeAuto");
            if (typeof savedAuto === "boolean") themeAuto.value = savedAuto;
            if (typeof savedDark === "boolean") {
              Quasar.Dark.set(savedDark);
              isDark.value = Quasar.Dark.isActive;
            }
          } catch {}
          // System theme auto-detect if no explicit preference stored
          let mediaQuery = null;
          let onMQChange = null;
          try {
            const hasSaved =
              typeof window.uStore?.local.get("themeDark") === "boolean";
            if (!hasSaved) {
              themeAuto.value = true;
            }
            if (themeAuto.value && typeof window.matchMedia === "function") {
              mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
              onMQChange = () => {
                if (themeAuto.value) {
                  Quasar.Dark.set(mediaQuery.matches);
                  isDark.value = Quasar.Dark.isActive;
                }
              };
              onMQChange();
              if (mediaQuery.addEventListener)
                mediaQuery.addEventListener("change", onMQChange);
              else if (mediaQuery.addListener)
                mediaQuery.addListener(onMQChange);
            }
          } catch {}
          const reconnecting = ref(false);
          const retryAttempt = ref(0);
          const nextRetryIn = ref(0);
          let typingTimeout = null;
          let reconnectTimer = null;
          let countdownTimer = null;
          function notify(opts) {
            if (!notifyEnabled.value) return;
            try {
              Quasar.Notify.create(
                Object.assign({ position: "top-right", timeout: 2500 }, opts)
              );
            } catch (e) {}
          }
          function clearReconnectTimers() {
            if (reconnectTimer) {
              clearTimeout(reconnectTimer);
              reconnectTimer = null;
            }
            if (countdownTimer) {
              clearInterval(countdownTimer);
              countdownTimer = null;
            }
          }
          function scheduleReconnect() {
            if (reconnectTimer) return; // already scheduled
            reconnecting.value = true;
            const delays = [1000, 2000, 5000, 10000, 20000, 30000];
            const idx = Math.min(retryAttempt.value, delays.length - 1);
            const delay = delays[idx];
            nextRetryIn.value = Math.ceil(delay / 1000);
            clearReconnectTimers();
            countdownTimer = setInterval(() => {
              if (nextRetryIn.value > 0) nextRetryIn.value -= 1;
            }, 1000);
            reconnectTimer = setTimeout(() => {
              reconnectTimer = null;
              connect();
            }, delay);
            retryAttempt.value += 1;
          }
          function retryNow() {
            clearReconnectTimers();
            connect();
          }
          function connect() {
            socket.value = new WebSocket(WS_URL);
            socket.value.onopen = () => {
              connected.value = true;
              reconnecting.value = false;
              clearReconnectTimers();
              if (retryAttempt.value > 0) {
                notify({
                  color: "positive",
                  message: "Reconnected",
                  caption: clientId.value ? clientId.value.substring(0, 8) : "",
                });
              } else {
                notify({
                  color: "positive",
                  message: "Connected",
                  caption: clientId.value ? clientId.value.substring(0, 8) : "",
                });
              }
              retryAttempt.value = 0;
            };
            socket.value.onmessage = (ev) => {
              const msg = JSON.parse(ev.data);
              switch (msg.type) {
                case "register-success":
                  clientId.value = msg.id;
                  try {
                    window.uStore?.local.set("clientId", msg.id);
                  } catch {}
                  notify({
                    color: "positive",
                    message: "Registered",
                    caption: msg.id.substring(0, 8),
                  });
                  break;
                case "user-list":
                  users.value = msg.users;
                  const othersCount = msg.users.filter(
                    (u) => u !== clientId.value
                  ).length;
                  notify({
                    color: "info",
                    message: "User list updated",
                    caption:
                      othersCount +
                      " other" +
                      (othersCount === 1 ? " user" : " users"),
                  });
                  break;
                case "message":
                  messages.value.push({
                    ...msg,
                    ts: new Date(),
                    me: msg.from === clientId.value,
                  });
                  if (msg.from !== clientId.value) {
                    notify({
                      color: msg.isBroadcast ? "accent" : "info",
                      message: msg.isBroadcast ? "Broadcast" : "Message",
                      caption:
                        (msg.from || "").substring(0, 8) +
                        ": " +
                        String(msg.payload).slice(0, 28),
                    });
                  }
                  break;
                case "message-history":
                  msg.history.forEach((h) =>
                    messages.value.push({
                      from: h.senderId,
                      payload: h.payload,
                      isBroadcast: h.isBroadcast,
                      ts: new Date(h.timestamp),
                      me: h.senderId === clientId.value,
                    })
                  );
                  notify({
                    color: "info",
                    message: "History loaded",
                    caption: msg.history.length + " messages",
                  });
                  break;
                case "user-typing":
                  typingUsers.value.add(msg.id);
                  break;
                case "user-stopped-typing":
                  typingUsers.value.delete(msg.id);
                  break;
                case "joined-room":
                  roomId.value = msg.roomId;
                  roomPartner.value = msg.with;
                  notify({
                    color: "positive",
                    message: "Room joined",
                    caption: (msg.with || "").substring(0, 8),
                  });
                  break;
                case "partner-left-room":
                  roomId.value = null;
                  roomPartner.value = null;
                  notify({
                    color: "warning",
                    message: "Room closed",
                    caption: "Partner left",
                  });
                  break;
                case "error":
                  notify({
                    color: "negative",
                    message: "Error",
                    caption: msg.message || "Unknown",
                  });
                  break;
              }
            };
            socket.value.onclose = () => {
              connected.value = false;
              notify({
                color: "negative",
                message: "Disconnected",
                caption: "Socket closed",
              });
              scheduleReconnect();
            };
            socket.value.onerror = () =>
              notify({ color: "warning", message: "Socket error" });
          }
          function sendMessage(broadcast = false) {
            const text = input.value.trim();
            if (!text) return;
            if (broadcast) {
              socket.value?.send(
                JSON.stringify({ type: "broadcast", payload: text })
              );
            } else if (roomId.value && roomPartner.value) {
              socket.value?.send(
                JSON.stringify({ type: "room-message", payload: text })
              );
              messages.value.push({
                type: "message",
                from: clientId.value,
                payload: text,
                ts: new Date(),
                me: true,
              });
            } else {
              const dest = selectedUser.value;
              if (dest) {
                socket.value?.send(
                  JSON.stringify({ type: "route", to: dest, payload: text })
                );
                messages.value.push({
                  type: "message",
                  from: clientId.value,
                  payload: text,
                  ts: new Date(),
                  me: true,
                });
              }
            }
            input.value = "";
            socket.value?.send(JSON.stringify({ type: "stop-typing" }));
          }
          function chooseUser(u) {
            selectedUser.value = u;
          }
          function loadHistory() {
            socket.value?.send(JSON.stringify({ type: "get-history" }));
            notify({ color: "info", message: "Requesting history..." });
          }
          function startRoom() {
            if (!selectedUser.value) return;
            socket.value?.send(
              JSON.stringify({ type: "join-room", with: selectedUser.value })
            );
            notify({
              color: "info",
              message: "Joining room",
              caption: selectedUser.value.substring(0, 8),
            });
          }
          function leaveRoom() {
            roomId.value = null;
            roomPartner.value = null;
            notify({ color: "warning", message: "Left room" });
          }
          function handleTyping() {
            socket.value?.send(JSON.stringify({ type: "start-typing" }));
            clearTimeout(typingTimeout);
            typingTimeout = setTimeout(
              () => socket.value?.send(JSON.stringify({ type: "stop-typing" })),
              1200
            );
          }
          const typingLabel = computed(() => {
            const arr = Array.from(typingUsers.value).filter(
              (id) => id !== clientId.value
            );
            if (!arr.length) return "";
            return (
              (arr.length === 1 ? arr[0] : arr.length + " users") + " typing…"
            );
          });
          onMounted(connect);
          // Persist small UI state changes
          try {
            watch(notifyEnabled, (v) =>
              window.uStore?.local.set("notifyEnabled", !!v)
            );
            watch(selectedUser, (v) =>
              window.uStore?.local.set("selectedUser", v || "")
            );
            watch(input, (v) =>
              window.uStore?.local.set("inputDraft", v || "")
            );
            watch(isDark, (v) => {
              Quasar.Dark.set(v);
              window.uStore?.local.set("themeDark", v);
            });
            watch(themeAuto, (v) => {
              window.uStore?.local.set("themeAuto", v);
              if (v) {
                // Re-enable media query listener
                if (!mediaQuery && typeof window.matchMedia === "function") {
                  mediaQuery = window.matchMedia(
                    "(prefers-color-scheme: dark)"
                  );
                }
                if (mediaQuery) {
                  if (!onMQChange) {
                    onMQChange = () => {
                      if (themeAuto.value) {
                        Quasar.Dark.set(mediaQuery.matches);
                        isDark.value = Quasar.Dark.isActive;
                      }
                    };
                  }
                  onMQChange();
                  if (mediaQuery.addEventListener)
                    mediaQuery.addEventListener("change", onMQChange);
                  else if (mediaQuery.addListener)
                    mediaQuery.addListener(onMQChange);
                }
              } else if (mediaQuery && onMQChange) {
                if (mediaQuery.removeEventListener)
                  mediaQuery.removeEventListener("change", onMQChange);
                else if (mediaQuery.removeListener)
                  mediaQuery.removeListener(onMQChange);
              }
            });
          } catch {}
          return {
            connected,
            clientId,
            users,
            messages,
            input,
            typingLabel,
            sendMessage,
            chooseUser,
            selectedUser,
            loadHistory,
            startRoom,
            leaveRoom,
            handleTyping,
            roomId,
            roomPartner,
            reconnecting,
            retryAttempt,
            nextRetryIn,
            retryNow,
            notifyEnabled,
            colorFor,
            isDark,
            toggleDark: () => {
              themeAuto.value = false; // manual override disables auto
              isDark.value = !isDark.value;
            },
            themeAuto,
            themeButtonLabel,
            themeButtonIcon,
          };
        },
        template: `<q-layout view="hHh lpR fFf">
          <q-header elevated class="bg-primary text-white">
            <q-toolbar>
              <q-toolbar-title>Messaging Hub <span v-if=\"clientId\">- {{ clientId.substring(0,8) }}</span></q-toolbar-title>
              <q-btn dense flat icon="history" @click="loadHistory" label="History" />
              <q-btn dense flat icon="campaign" @click="sendMessage(true)" label="Broadcast" />
              <q-btn dense flat :icon="themeButtonIcon" @click="toggleDark" :label="themeButtonLabel" />
              <q-space />
              <q-btn dense flat round icon="settings">
                <q-menu anchor="bottom right" self="top right">
                  <q-list dense style="min-width:220px;">
                    <q-item>
                      <q-item-section>Enable notifications</q-item-section>
                      <q-item-section side>
                        <q-toggle v-model="notifyEnabled" :label="notifyEnabled ? 'On' : 'Off'" left-label />
                      </q-item-section>
                    </q-item>
                     <q-item>
                       <q-item-section>Auto theme</q-item-section>
                       <q-item-section side>
                         <q-toggle v-model="themeAuto" :label="themeAuto ? 'System' : 'Manual'" left-label />
                       </q-item-section>
                     </q-item>
                  </q-list>
                </q-menu>
              </q-btn>
            </q-toolbar>
            <div class="q-pa-sm q-pt-none">
              <q-banner v-if="reconnecting" dense class="bg-warning text-dark">
                Reconnecting in {{ nextRetryIn }}s… (attempt {{ retryAttempt }})
                <template v-slot:action>
                  <q-btn flat color="dark" label="Retry now" @click="retryNow" />
                </template>
              </q-banner>
            </div>
          </q-header>
          <q-page-container>
            <q-page class="row no-wrap">
              <div class="column col-auto q-pa-sm" style="width:260px;max-width:100%;">
                <q-card flat bordered class="full-height">
                  <q-card-section class="q-pb-xs"><div class="text-caption text-grey">Users Online</div></q-card-section>
                  <q-list dense bordered separator style="max-height:40vh;overflow:auto;">
                    <q-item v-for="u in users" :key="u" clickable @click="u!==clientId && chooseUser(u)" :active="selectedUser===u" :disable="u===clientId" active-class="bg-primary text-white">
                      <q-item-section avatar style="min-width:28px;">
                        <q-badge :color="u===clientId ? 'primary' : colorFor(u)" rounded style="width:14px;height:14px;padding:0;" />
                      </q-item-section>
                      <q-item-section>
                        {{ u.substring(0,8) }}<span v-if="u===clientId" class="text-primary text-caption"> (you)</span>
                      </q-item-section>
                    </q-item>
                    <q-item v-if="!users.length"><q-item-section class="text-grey">No users</q-item-section></q-item>
                  </q-list>
                  <q-separator />
                  <q-card-section>
                    <div class="text-caption">Room</div>
                    <div v-if="roomId" class="q-mt-xs">
                      <q-badge color="primary" class="q-mr-sm">{{ roomId }}</q-badge>
                      <q-badge color="secondary">with {{ roomPartner?.substring(0,8) }}</q-badge>
                    </div>
                    <div class="q-mt-sm flex">
                      <q-btn size="sm" color="primary" :disable="!selectedUser" label="Start" @click="startRoom" class="q-mr-xs" />
                      <q-btn size="sm" flat color="negative" :disable="!roomId" label="Leave" @click="leaveRoom" />
                    </div>
                  </q-card-section>
                </q-card>
              </div>
              <div class="column col q-pa-sm">
                <q-card flat bordered class="column full-height">
                  <q-card-section class="col scroll" style="overflow:auto;display:flex;flex-direction:column;gap:8px;">
                    <div v-for="m in messages" :key="m.ts.getTime()+m.payload" class="message-item" :class="{ me:m.me, broadcast:m.isBroadcast }">
                      <q-chat-message :sent="m.me" :text="[m.payload]" :bg-color="m.isBroadcast ? 'accent' : (m.me ? 'primary' : 'secondary')" text-color="white" :stamp="m.ts.toLocaleTimeString()" :name="m.me ? 'You' : m.from.substring(0,8)">
                        <template v-slot:avatar>
                          <q-avatar :color="m.isBroadcast ? 'accent' : (m.me ? 'primary' : colorFor(m.from))" text-color="white" size="32px">{{ m.isBroadcast ? '★' : m.me ? 'Y' : m.from.substring(0,2) }}</q-avatar>
                        </template>
                      </q-chat-message>
                    </div>
                  </q-card-section>
                  <q-separator />
                  <q-card-section>
                    <q-input dense outlined v-model="input" placeholder="Type a message" @keyup="handleTyping" @keyup.enter="sendMessage(false)" />
                    <div class="row items-center q-gutter-sm q-mt-sm">
                      <q-btn color="primary" label="Send" @click="sendMessage(false)" :disable="!input.trim()" />
                      <q-btn flat color="accent" label="Broadcast" @click="sendMessage(true)" :disable="!input.trim()" />
                      <q-btn flat color="secondary" label="History" @click="loadHistory" />
                      <q-badge v-if="typingLabel" color="warning" class="q-ml-auto">{{ typingLabel }}</q-badge>
                    </div>
                  </q-card-section>
                </q-card>
              </div>
            </q-page>
          </q-page-container>
        </q-layout>`,
      });
      app.use(Quasar);
      app.mount("#q-app");
      // Persist notification preference
      try {
        const appVm = document.getElementById("q-app");
      } catch {}
    </script>
  </body>
</html>
